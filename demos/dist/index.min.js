(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.EZG = {}));
}(this, (function (exports) { 'use strict';

    function dispatchCustomEvent(name, elm, detail, cancelable = true) {
        return !elm.dispatchEvent(
            new CustomEvent(`ezg${name}`, { detail, cancelable })
        );
    }

    let activeDraggedElement;
    let startX, startY;
    let lastX, lastY;
    let checkDragPos;

    const defaults$1 = {
        threshold: 0,
    };

    const options$1 = new WeakMap();

    function enableDragEvents(elm, opt = defaults$1) {
        elm.addEventListener("touchstart", onPointerDown, true);
        elm.addEventListener("mousedown", onPointerDown, true);
        options$1.set(elm, opt);
    }

    // create dummy mouse event object to get mouse related properties like e.clientX e.clientY, e.altKey, etc..
    Object.keys(
        Object.getPrototypeOf(new MouseEvent(""))
    );

    function getPointerPosition(e) {
        if (e.changedTouches) e = e.changedTouches[0];
        return [e.clientX, e.clientY];
    }

    function onPointerDown(e) {
        activeDraggedElement = e.currentTarget;
        checkDragPos = true;

        [startX, startY] = getPointerPosition(e);

        addOrRemoveEvents();
    }

    function onPointerMove(e) {
        e.preventDefault();
        if (!activeDraggedElement) return;

        const [x, y] = getPointerPosition(e);

        if (checkDragPos) {
            const opt = options$1.get(activeDraggedElement);

            if (Math.hypot(x - startX, y - startY) < opt.threshold) return;

            checkDragPos = false;
            [lastX, lastY] = [x, y];

            if (!dispatchDragEvent("dragstart", e)) {
                removeDragEvents();
            }
        } else if (dispatchDragEvent("dragmove", e)) {
            [lastX, lastY] = [x, y];
        }
    }

    function getDragPositions(e) {
        const [clientX, clientY] = getPointerPosition(e);
        return {
            startX,
            startY,
            lastX,
            lastY,

            //current mouse position
            clientX,
            clientY,

            // mouse delta from initial drag position
            offsetX: clientX - startX,
            offsetY: clientY - startY,

            // mouse delta from last drag position
            movementX: clientX - lastX,
            movementY: clientY - lastY,
        };
    }

    function removeDragEvents() {
        activeDraggedElement = undefined;

        addOrRemoveEvents(true);
    }

    function onPointerUp(e) {
        if (activeDraggedElement && !checkDragPos) {
            dispatchDragEvent("dragstop", e, false);
        }

        removeDragEvents();
    }

    function addOrRemoveEvents(remove) {
        const fn = remove ? "removeEventListener" : "addEventListener";
        document[fn]("mouseup", onPointerUp);
        document[fn]("touchend", onPointerUp);
        document[fn]("mousemove", onPointerMove);
        document[fn]("touchmove", onPointerMove);
    }

    function dispatchDragEvent(name, e, cancelable = true) {
        return !dispatchCustomEvent(
            name,
            activeDraggedElement,
            {
                ...getDragPositions(e),
                originalEvent: e,
            },
            cancelable
        );
    }

    let startTouches;
    let lastTouches;

    let activeElement;
    let checkPinch;

    let lastDist;
    let lastOffset;
    let lastAngle;

    const defaults = {
        distanceThreshold: 0,
        angleThreshold: 0,
    };

    const options = new WeakMap();

    function enablePinchEvents(elm, opt = defaults) {
        options.set(elm, opt);
        elm.addEventListener("touchstart", onTouchStart);
    }

    function onTouchStart(e) {
        startTouches = e.touches;
        checkPinch = true;
        e.currentTarget.addEventListener("touchmove", onTouchMove);
    }

    function onTouchMove(e) {
        e.preventDefault();
        if (e.touches.length != 2) return;

        const props = calculatePinchProps(e.touches);

        if (checkPinch) {
            pinchStartHandler(e, props);
        } else {
            pinchMoveHandler(e, props);
        }
    }

    function pinchStartHandler(e, { dist, angle }) {
        if (startTouches.length != 2) return;
        const { dist: startDist, angle: startAngle } = calculatePinchProps(
            startTouches
        );

        const { distanceThreshold, angleThreshold } = options.get(e.currentTarget);

        const dd = Math.abs(dist - startDist);
        const da = Math.abs(angle - startAngle);

        if (dd >= distanceThreshold && da >= angleThreshold) {
            const isCancelled = dispatchCustomEvent("pinchstart", e.currentTarget, {
                startTouches,
                originalEvent: e,
            });

            if (isCancelled) {
                return elm.removeEventListener("touchmove", onTouchMove);
            }

            activeElement = e.currentTarget;
            lastDist = startDist;
            lastAngle = startAngle;
            lastOffset = 0;
            checkPinch = false;
            document.addEventListener("touchend", onTouchEnd);
        }
    }

    function pinchMoveHandler(e, props) {
        const { angle, offset, dist } = props;
        const isCancelled = dispatchPinchEvent("move", e.currentTarget, {
            ...props,
            originalEvent: e,
            touches: e.touches,
        });

        // will stop counting lastDist/Offset when cancelled
        if (isCancelled) return;

        lastDist = dist;
        lastAngle = angle;
        lastOffset = offset;
    }

    function calculatePinchProps(touches) {
        const [p1, p2] = touches;

        const dx = p1.clientX - p2.clientX;
        const dy = p1.clientY - p2.clientY;

        const dist = Math.hypot(dx, dy);
        const offset = dist - lastDist;

        const angle = Math.atan2(dy, dx);
        const da = angle - lastAngle;

        const midX = (p1.clientX + p2.clientX) / 2;
        const midY = (p1.clientY + p2.clientY) / 2;

        const dir = Math.sign(dist - (lastDist || dist));

        return { dx, dy, da, dist, angle, offset, midX, midY, dir };
    }

    function onTouchEnd(e) {
        if (!checkPinch && activeElement) {
            dispatchPinchEvent("end", activeElement, null, false);
            activeElement = undefined;
        }
    }

    function dispatchPinchEvent(ev, elm, detail, cancelable) {
        detail = {
            ...detail,
            startTouches,
            lastTouches,
            lastOffset,
            lastDist,
            lastAngle,
        };
        return dispatchCustomEvent(`pinch${ev}`, elm, detail, cancelable);
    }

    exports.enableDragEvents = enableDragEvents;
    exports.enablePinchEvents = enablePinchEvents;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.min.js.map
